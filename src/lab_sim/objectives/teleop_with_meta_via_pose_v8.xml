<?xml version='1.0' encoding='UTF-8'?>
<root BTCPP_format="4" main_tree_to_execute="Teleop With Meta via Pose v8">
  <BehaviorTree ID="Teleop With Meta via Pose v8" _description="" _favorite="false">
    <Control ID="Sequence" name="TopLevelSequence">
      <Control ID="Sequence">
        <!--Get grasp_link position-->
        <Action ID="CreateStampedPose" reference_frame="grasp_link" stamped_pose="{grasp_link_pose}" name="Get current pose of grasp_link"/>
        <Action ID="TransformPoseFrame" input_pose="{grasp_link_pose}" output_pose="{grasp_link_pose}" target_frame_id="world"/>
        <!--Get controller pose for rotation reference-->
        <Action ID="GetOdomInstance" odom_topic_name="/right_controller_odom" subscribed_odom_instance="{odometry}" name="Get controller odom for rotation reference"/>
        <Action ID="ConvertOdomToPoseStamped" pose_stamped="{controller_initial_pose}" odometry="{odometry}"/>
        <Action ID="TransformPoseFrame" input_pose="{controller_initial_pose}" output_pose="{controller_initial_pose}" target_frame_id="world"/>
        <!--Extract position from grasp_link-->
        <Action ID="UnpackPoseStampedMessage" pose_stamped="{grasp_link_pose}" pose="{grasp_pose_raw}" header="{grasp_header}"/>
        <Action ID="UnpackPoseMessage" pose="{grasp_pose_raw}" position="{grasp_position}" orientation="{grasp_orientation_unused}"/>
        <!--Extract rotation from controller-->
        <Action ID="UnpackPoseStampedMessage" pose_stamped="{controller_initial_pose}" pose="{controller_pose_raw}" header="{controller_header_unused}"/>
        <Action ID="UnpackPoseMessage" pose="{controller_pose_raw}" position="{controller_position_unused}" orientation="{controller_orientation}"/>
        <!--Combine: grasp_link position + controller rotation-->
        <Action ID="CreatePoseMessage" position="{grasp_position}" orientation="{controller_orientation}" pose="{combined_pose}"/>
        <Action ID="CreatePoseStampedMessage" pose="{combined_pose}" header="{grasp_header}" pose_stamped="{initial_grasp_pose}"/>
        <Action ID="VisualizePose" pose="{initial_grasp_pose}" marker_name="initial grasp pose" marker_size="0.100000" marker_text="i_g"/>
        <!--Store initial controller pose (in quest frame as before)-->
        <Action ID="GetOdomInstance" odom_topic_name="/right_controller_odom" subscribed_odom_instance="{odometry}" name="Store initial pose of controller upon grip event"/>
        <Action ID="ConvertOdomToPoseStamped" pose_stamped="{initial_controller_pose}" odometry="{odometry}"/>
        <Action ID="VisualizePose" pose="{initial_controller_pose}" marker_name="initial controller pose" marker_text="i_c"/>
        <Action ID="TransformPoseFrame" input_pose="{initial_controller_pose}" output_pose="{initial_controller_pose}" target_frame_id="quest"/>
      </Control>
      <Action ID="SwitchController" activate_controllers="velocity_force_controller"/>
      <Control ID="Sequence" name="Initial values">
        <Action ID="CreateStampedWrench"/>
        <Action ID="CreateStampedTwist" reference_frame="world"/>
      </Control>
      <!--Initialize grip state tracking-->
      <Action ID="Script" code="current_grip := false"/>
      <Action ID="SetBlackboard" value="false" output_key="subscribed_bool"/>
      <Control ID="Parallel" failure_count="1" success_count="-1">
        <!--Branch 1: Monitor grip button state continuously-->
        <Decorator ID="KeepRunningUntilFailure">
          <Action ID="GetBool" bool_topic_name="right_grip_button_state" subscribed_bool="{subscribed_bool}"/>
        </Decorator>
        <!--Branch 2: Rising Edge Detection - keep running forever to detect multiple edges-->
        <Decorator ID="KeepRunningUntilFailure">
          <SubTree ID="Rising Edge Detection" bool_topic="right_grip_button_state" current_state="{edge_current_state}" rising_edge="{grip_rising_edge}"/>
        </Decorator>
        <!--Branch 3: Main control loop-->
        <Decorator ID="KeepRunningUntilFailure">
          <Control ID="Sequence" name="Compute the pose offset from initial_controller to current_controller and apply it to initial_grasp">
            <!--Store current grip state-->
            <Action ID="Script" code="current_grip := subscribed_bool"/>
            <!--Rising edge detection: when grip_rising_edge is true, re-align frames (position only snap)-->
            <Decorator ID="Precondition" else="SUCCESS" if="grip_rising_edge">
              <Control ID="Sequence" name="Re-align frames on grip button press (position-only snap)">
                <Action ID="LogMessage" message="Rising edge detected - re-aligning frames (position snap only)"/>
                <!--Get grasp_link position (robot's current position)-->
                <Action ID="CreateStampedPose" reference_frame="grasp_link" stamped_pose="{grasp_link_pose}" name="Get current pose of grasp_link"/>
                <Action ID="TransformPoseFrame" input_pose="{grasp_link_pose}" output_pose="{grasp_link_pose}" target_frame_id="world"/>
                <!--Get controller pose for rotation reference-->
                <Action ID="GetOdomInstance" odom_topic_name="/right_controller_odom" subscribed_odom_instance="{odometry}" name="Get controller odom for rotation reference"/>
                <Action ID="ConvertOdomToPoseStamped" pose_stamped="{controller_initial_pose}" odometry="{odometry}"/>
                <Action ID="TransformPoseFrame" input_pose="{controller_initial_pose}" output_pose="{controller_initial_pose}" target_frame_id="world"/>
                <!--Extract position from grasp_link-->
                <Action ID="UnpackPoseStampedMessage" pose_stamped="{grasp_link_pose}" pose="{grasp_pose_raw}" header="{grasp_header}"/>
                <Action ID="UnpackPoseMessage" pose="{grasp_pose_raw}" position="{grasp_position}" orientation="{grasp_orientation_unused}"/>
                <!--Extract rotation from controller-->
                <Action ID="UnpackPoseStampedMessage" pose_stamped="{controller_initial_pose}" pose="{controller_pose_raw}" header="{controller_header_unused}"/>
                <Action ID="UnpackPoseMessage" pose="{controller_pose_raw}" position="{controller_position_unused}" orientation="{controller_orientation}"/>
                <!--Combine: grasp_link position + controller rotation = initial_grasp_pose-->
                <Action ID="CreatePoseMessage" position="{grasp_position}" orientation="{controller_orientation}" pose="{combined_pose}"/>
                <Action ID="CreatePoseStampedMessage" pose="{combined_pose}" header="{grasp_header}" pose_stamped="{initial_grasp_pose}"/>
                <Action ID="VisualizePose" pose="{initial_grasp_pose}" marker_name="initial grasp pose" marker_size="0.100000" marker_text="i_g"/>
                <!--Re-capture initial controller pose (for offset calculation)-->
                <Action ID="GetOdomInstance" odom_topic_name="/right_controller_odom" subscribed_odom_instance="{odometry}" name="Re-store initial pose of controller"/>
                <Action ID="ConvertOdomToPoseStamped" pose_stamped="{initial_controller_pose}" odometry="{odometry}"/>
                <Action ID="VisualizePose" pose="{initial_controller_pose}" marker_name="initial controller pose" marker_text="i_c"/>
                <Action ID="TransformPoseFrame" input_pose="{initial_controller_pose}" output_pose="{initial_controller_pose}" target_frame_id="quest"/>
              </Control>
            </Decorator>
            <!--Only compute and publish when grip is held-->
            <Decorator ID="Precondition" else="SUCCESS" if="current_grip">
              <Control ID="Sequence" name="Compute and publish target when clutch is depressed">
                <Action ID="GetOdomInstance" odom_topic_name="/right_controller_odom" subscribed_odom_instance="{odometry}"/>
                <Action ID="ConvertOdomToPoseStamped" pose_stamped="{controller_pose}" odometry="{odometry}"/>
                <Action ID="CalculatePoseOffset" destination_pose="{controller_pose}" source_pose="{initial_controller_pose}" source_to_destination_pose="{pose_transform}"/>
                <Control ID="Sequence" name="I don't remember having to do this unpacking-repacking nonsense the first time I wrote this, but this seems to do the trick.">
                  <Action ID="UnpackPoseStampedMessage" pose_stamped="{pose_transform}"/>
                  <Action ID="UnpackPoseMessage" position="{point}" orientation="{quaternion}"/>
                  <Control ID="Sequence">
                    <Action ID="UnpackPointMessage" x="{x}"/>
                    <Action ID="ResetVector" vector="{vec_position}"/>
                    <Action ID="InsertInVector" index="0" input_vector="{vec_position}" output_vector="{vec_position}" element="{x}"/>
                    <Action ID="InsertInVector" index="1" input_vector="{vec_position}" output_vector="{vec_position}" element="{y}"/>
                    <Action ID="InsertInVector" index="2" input_vector="{vec_position}" output_vector="{vec_position}" element="{z}"/>
                    <Action ID="UnpackQuaternionMessage" w="{qw}" x="{qx}" y="{qy}" z="{qz}"/>
                    <Action ID="ResetVector" vector="{vec_quaternion}"/>
                    <Action ID="InsertInVector" output_vector="{vec_quaternion}" input_vector="{vec_quaternion}" index="0" element="{qx}"/>
                    <Action ID="InsertInVector" output_vector="{vec_quaternion}" input_vector="{vec_quaternion}" index="1" element="{qy}"/>
                    <Action ID="InsertInVector" output_vector="{vec_quaternion}" input_vector="{vec_quaternion}" index="2" element="{qz}"/>
                    <Action ID="InsertInVector" output_vector="{vec_quaternion}" input_vector="{vec_quaternion}" index="3" element="{qw}"/>
                  </Control>
                </Control>
                <Action ID="TransformPose" quaternion_xyzw="{vec_quaternion}" translation_xyz="{vec_position}" input_pose="{initial_grasp_pose}" output_pose="{target_pose}"/>
                <Action ID="VisualizePose" pose="{target_pose}" marker_text="target" marker_size="0.1" marker_name="target"/>
                <Action ID="VisualizePose" pose="{controller_pose}" marker_name="controller" marker_text="controller"/>
                <Control ID="Sequence">
                  <Action ID="ConvertPoseStampedToOdom" odom="{target_odom}" pose_stamped="{target_pose}"/>
                  <Action ID="CreateStampedPose" stamped_pose="{target_pose_offset}"/>
                  <Action ID="ComputeVelocityToAlignWithTarget" target_motion_state="{target_odom}" target_pose_offset="{target_pose_offset}" output_control_velocity="{stamped_twist}" proportional_gain_angular=".5" proportional_gain_linear=".4"/>
                  <Action ID="CreateStampedWrench" reference_frame="grasp_link"/>
                </Control>
              </Control>
            </Decorator>
          </Control>
        </Decorator>
        <!--Branch 4: Continuously publish velocity commands-->
        <Action ID="PublishVelocityForceCommand" twist_stamped="{stamped_twist}" wrench_stamped="{stamped_wrench}" velocity_controlled_axes="1;1;1;1;1;1" publish_rate="10" velocity_force_controller_command_topic="/velocity_force_controller/command"/>
      </Control>
    </Control>
  </BehaviorTree>
  <TreeNodesModel>
    <SubTree ID="Teleop With Meta via Pose v8">
      <MetadataFields>
        <Metadata runnable="true"/>
        <Metadata subcategory="User Input"/>
      </MetadataFields>
    </SubTree>
  </TreeNodesModel>
</root>
